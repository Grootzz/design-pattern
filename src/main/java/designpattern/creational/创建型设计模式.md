# 创建型设计模式

创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。

创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。

- **简单工厂模式（Simple Factory）**【重要程度：4 （5为满分）】
- **工厂方法模式（Factory Method）**【重要程度：5】
- **抽象工厂模式（Abstract Factory）**【重要程度：5】
- **建造者模式（Builder）**【重要程度：2】
- **原型模式（Prototype）**【重要程度：3】
- **单例模式（Singleton）**【重要程度：4】

## 单例模式

单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。

单例模式的实现过程中，需要注意如下三点：

- 单例类的构造函数为私有；
- 提供一个自身的静态私有成员变量；
- 提供一个公有的静态工厂方法。

根据是否线程安全和类的实例化时机，可以将单例模式分为以下几类

- 饿汉方式(线程安全)
- 懒汉式（非线程安全）
- 懒汉式（双重检查加锁版本）
- 懒汉式（synchronized关键字线程安全版本）
- 懒汉式（登记式/静态内部类方式）

### 饿汉方式(线程安全)

```java
public class Singleton {

    /**
     * 在类加载阶段的 初始化阶段 创建实例
     * 因为 初始化阶段 的<clinit>()方法是线程安全的，所以这种方式创建对象线程安全
     */
    private static Singleton unique = new Singleton();

    private Singleton() {
    }

    public static Singleton getInstance() {
        return unique;
    }
}
```

这种方式在JVM加载类时创建实例，保证了线程安全，但是，如果这个实例创建后没有使用，则会造成内存浪费，以空间换时间。

### 懒汉式（非线程安全）

```java
public class Singleton2 {

    private static Singleton2 unique = null;

    private Singleton2() {
    }

    /**
     * 没有加入synchronized关键字,是线程不安全的
     *
     * @return
     */
    public static Singleton2 getInstance() {
        // 判断当前单例是否已经存在，若存在则返回，不存在则再建立单例
        if (unique == null) {
            unique = new Singleton2();
        }
        return unique;
    }
}
```

这种方式在单线程情况下没有问题，使用的时候才实例化，但是多线程时，线程不安全。

### 懒汉式（synchronized关键字线程安全版本）

```java
public class Singleton3 {

    private static Singleton3 unique = null;

    private Singleton3() {
    }

    /**
     * 没有加入synchronized关键字,是线程不安全的
     * 但是因为引入了synchronized锁，所以，获取锁会有额外的开销
     *
     * @return
     */
    public static synchronized Singleton3 getInstance() {
        // 判断当前单例是否已经存在，若存在则返回，不存在则再建立单例
        if (unique == null) {
            unique = new Singleton3();
        }
        return unique;
    }
}
```

我们知道synchronized关键字偏重量级锁。虽然在JavaSE1.6之后synchronized关键字进行了主要包括：为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升。

但是在程序中每次使用getInstance() 都要经过synchronized加锁这一层，这难免会增加getInstance()的方法的时间消费，而且还可能会发生阻塞。我们下面介绍到的 **双重检查加锁版本** 就是为了解决这个问题而存在的。

### 懒汉式（双重检查加锁版本）

利用双重检查加锁（double-checked locking），首先检查是否实例已经创建，如果尚未创建，“才”进行同步。这样以来，只有一次同步，这正是我们想要的效果。

很明显，这种方式相比于使用synchronized关键字的方法，可以大大减少getInstance() 的时间消费。

```java
/**
 * 懒汉式（synchronized关键字线程安全版本）
 */
public class Singleton4 {

    /**
     * volatile防止指令重排序（多线程情形，指令重排序会引发线程安全问题）
     */
    private static volatile Singleton4 unique = null;

    private Singleton4() {
    }

    /**
     * 没有加入synchronized关键字,是线程不安全的
     * 但是因为引入了synchronized锁，所以，获取锁会有额外的开销
     *
     * @return
     */
    public static Singleton4 getInstance() {
        // 判断当前单例是否已经存在，若存在则返回，不存在则再建立单例
        if (unique == null) {
            synchronized (Singleton4.class){
                if (unique == null) {
                    unique = new Singleton4();
                }
            }
        }
        return unique;
    }
}
```

### 懒汉式（登记式/静态内部类方式）

静态内部实现的单例是懒加载的且线程安全。

只有通过显式调用` getInstance()` 方法时，才会显式装载 `ingletonHolder `类，从而实例化` instance`（只有第一次使用这个单例的实例的时候才加载，同时不会有线程安全问题）。

```java
public class Singleton5 {
    private Singleton5() {
    }

    /**
     * 静态内部类中实例化
     */
    private static class SingletonHolder {
        private static final Singleton5 SINGLETON = new Singleton5();
    }

    public static final Singleton5 getInstance() {
        return SingletonHolder.SINGLETON;
    }
}
```






# 创建型设计模式

创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。

创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。

- **简单工厂模式（Simple Factory）**【重要程度：4 （5为满分）】
- **工厂方法模式（Factory Method）**【重要程度：5】
- **抽象工厂模式（Abstract Factory）**【重要程度：5】
- **建造者模式（Builder）**【重要程度：2】
- **原型模式（Prototype）**【重要程度：3】
- **单例模式（Singleton）**【重要程度：4】

## 单例模式

单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。

单例模式的实现过程中，需要注意如下三点：

- 单例类的构造函数为私有；
- 提供一个自身的静态私有成员变量；
- 提供一个公有的静态工厂方法。

根据是否线程安全和类的实例化时机，可以将单例模式分为以下几类

- 饿汉方式(线程安全)
- 懒汉式（非线程安全）
- 懒汉式（双重检查加锁版本）
- 懒汉式（synchronized关键字线程安全版本）
- 懒汉式（登记式/静态内部类方式）

### 饿汉方式(线程安全)

```java
public class Singleton {

    /**
     * 在类加载阶段的 初始化阶段 创建实例
     * 因为 初始化阶段 的<clinit>()方法是线程安全的，所以这种方式创建对象线程安全
     */
    private static Singleton unique = new Singleton();

    private Singleton() {
    }

    public static Singleton getInstance() {
        return unique;
    }
}
```

这种方式在JVM加载类时创建实例，保证了线程安全，但是，如果这个实例创建后没有使用，则会造成内存浪费，以空间换时间。

### 懒汉式（非线程安全）

```java
public class Singleton2 {

    private static Singleton2 unique = null;

    private Singleton2() {
    }

    /**
     * 没有加入synchronized关键字,是线程不安全的
     *
     * @return
     */
    public static Singleton2 getInstance() {
        // 判断当前单例是否已经存在，若存在则返回，不存在则再建立单例
        if (unique == null) {
            unique = new Singleton2();
        }
        return unique;
    }
}
```

这种方式在单线程情况下没有问题，使用的时候才实例化，但是多线程时，线程不安全。

### 懒汉式（synchronized关键字线程安全版本）

```java
public class Singleton3 {

    private static Singleton3 unique = null;

    private Singleton3() {
    }

    /**
     * 没有加入synchronized关键字,是线程不安全的
     * 但是因为引入了synchronized锁，所以，获取锁会有额外的开销
     *
     * @return
     */
    public static synchronized Singleton3 getInstance() {
        // 判断当前单例是否已经存在，若存在则返回，不存在则再建立单例
        if (unique == null) {
            unique = new Singleton3();
        }
        return unique;
    }
}
```

我们知道synchronized关键字偏重量级锁。虽然在JavaSE1.6之后synchronized关键字进行了主要包括：为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升。

但是在程序中每次使用getInstance() 都要经过synchronized加锁这一层，这难免会增加getInstance()的方法的时间消费，而且还可能会发生阻塞。我们下面介绍到的 **双重检查加锁版本** 就是为了解决这个问题而存在的。

### 懒汉式（双重检查加锁版本）

利用双重检查加锁（double-checked locking），首先检查是否实例已经创建，如果尚未创建，“才”进行同步。这样以来，只有一次同步，这正是我们想要的效果。

很明显，这种方式相比于使用synchronized关键字的方法，可以大大减少getInstance() 的时间消费。

```java
/**
 * 懒汉式（synchronized关键字线程安全版本）
 */
public class Singleton4 {

    /**
     * volatile防止指令重排序（多线程情形，指令重排序会引发线程安全问题）
     */
    private static volatile Singleton4 unique = null;

    private Singleton4() {
    }

    /**
     * 没有加入synchronized关键字,是线程不安全的
     * 但是因为引入了synchronized锁，所以，获取锁会有额外的开销
     *
     * @return
     */
    public static Singleton4 getInstance() {
        // 判断当前单例是否已经存在，若存在则返回，不存在则再建立单例
        if (unique == null) {
            synchronized (Singleton4.class){
                if (unique == null) {
                    unique = new Singleton4();
                }
            }
        }
        return unique;
    }
}
```

### 懒汉式（登记式/静态内部类方式）

静态内部实现的单例是懒加载的且线程安全。

只有通过显式调用` getInstance()` 方法时，才会显式装载 `ingletonHolder `类，从而实例化` instance`（只有第一次使用这个单例的实例的时候才加载，同时不会有线程安全问题）。

```java
public class Singleton5 {
    private Singleton5() {
    }

    /**
     * 静态内部类中实例化
     */
    private static class SingletonHolder {
        private static final Singleton5 SINGLETON = new Singleton5();
    }

    public static final Singleton5 getInstance() {
        return SingletonHolder.SINGLETON;
    }
}
```

## 简单工厂模式

简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。

### 模式结构
简单工厂模式包含如下角色：

- 工厂角色(Factory)：工厂角色负责实现创建所有实例的内部逻辑
- 抽象产品角色(Product)：抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口
- 具体产品角色(ConcreteProduct)：具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。

### 模式分析
- 将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。
- 在调用工厂类的工厂方法时，由于工厂方法是静态方法，使用起来很方便，可通过类名直接调用，而且只需要传入一个简单的参数即可，在实际开发中，还可以在调用时将所传入的参数保存在XML等格式的配置文件中，修改参数时无须修改任何源代码。
- 简单工厂模式最大的问题在于工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，这一点与开闭原则是相违背的。
- 简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。

### 实例

